name: cd

on:
  push:
    branches: ["main"]
    tags: ["[0-9]*.[0-9]*.[0-9]*"]
    paths:
      # only rebuild when app code changes
      - "terraform/**/*"
      # exclude these files
      - "!terraform/backend.sh"
      - "!terraform/delete-backend.sh"
      - "!terraform/Taskfile.yaml"
      - "!terraform/tests/**/*"
  pull_request:
  workflow_dispatch:

jobs:
  # Deploy the infra with terraform
  terraform:
    name: Terraform
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform/envs/staging
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Terraform Format
        id: fmt
        run: terraform fmt -check

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request'        # Issue terraform plan only for pull requests
        run: terraform plan -no-color
        continue-on-error: true

      # Pull results from terraform plan and display in github actions interface
      - uses: actions/github-script@0.9.0
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style ðŸ–Œ\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization \`${{ steps.init.outcome }}\`
            #### Terraform Plan \`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`${process.env.PLAN}\`\`\`

            </details>

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

              
            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      # If plan outcome is a failure, stop the workflow
      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      - name : Terraform Test Execution
        if: github.event_name == 'pull_request'
        working-directory: terraform/tests/bash
        run: ./test-production.sh

      # Apply staging env for a push to main
      - name: Terraform Apply Staging
        working-directory: terraform/envs/staging
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve

      # Apply production env for a release tag
      - name: Terraform Apply Production
        working-directory: terraform/envs/production
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          terraform init
          terraform apply -auto-approve

  # Apply ArgoCD GitOps to GKE with helm
  argocd:
    name: ArgoCD
    needs: terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
  
      # Authenticate to GCP (Workload Identity preferred)
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
  
      # --- Tools ---
      - name: Install kubectl
        uses: azure/setup-kubectl@v4
  
      - name: Install Helm
        uses: azure/setup-helm@v4
  
      - name: Install yq
        run: |
          sudo snap install yq
  
      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
  
      # --- GCP Auth ---
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials \
            ${{ secrets.GKE_CLUSTER_NAME }} \
            --region ${{ secrets.GKE_REGION }} \
            --project ${{ secrets.GCP_PROJECT_ID }}
  
      # Sanity check for cluster access
      - name: Verify cluster access
        run: |
          kubectl cluster-info
          kubectl get ns
  
      # ==========================================================
      # RENDER (FAIL FAST)
      # ==========================================================
      # Render staging/production env manifest for application, if it fails, stop the job
      - name: Render ArgoCD staging applications
        working-directory: k8s/helm/
        if: github.ref == 'refs/heads/main'
        run: |
          task argocd:01-render-staging
          
      - name: Render ArgoCD production applications
        working-directory: k8s/helm/
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          task argocd:01-render-production
  
      # ==========================================================
      # APPLY (ONLY IF RENDER PASSED)
      # ==========================================================
      # Install / upgrade ArgoCD ApplicationSet (cluster-wide, once)
      - name: Install ArgoCD ApplicationSet
        working-directory: k8s/helm/
        run: |
          task argocd:00-install-argocd-applicationset
  
      # Apply staging env manifests for a push to main
      - name: Apply ArgoCD staging applications
        working-directory: k8s/helm/
        if: github.ref == 'refs/heads/main'
        run: |
          task argocd:02-install-staging
  
      # Apply production env manifests for a release tag
      - name: Apply ArgoCD production applications
        working-directory: k8s/helm/
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          task argocd:02-install-production
